// Rholang macro parameters:
// minimumBond - the minimum bond allowed by the PoS
// maximumBond - the maximum bond allowed by PoS
// initialBonds - the initial bonds map
// epochLength - the length of the validation epoch in blocks
// quarantineLength - the length of the quarantine time in blocks

/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = a9585a0687761139ab3587a4938fb5ab9fcba675c79fefba889859674046d4a5
 2.  |            | given              | timestamp = 1559156420651
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a20a32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b1001
 8.  | 7, 1,      | secp256k1          | sig = 3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f
 9.  | 4,         | registry           | uri = rho:id:m3xk7h8r54dtqtwsrnxqzhe81baswey66nzw6m533nyd45ptyoybqr
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 */

new PoS,
    registryLookup(`rho:registry:lookup`),
    revAddressOps(`rho:rev:address`),
    revVaultCh, listOpsCh,
    getUser,
    getCurrentUserAddress,
    pickActiveValidators,
    runMVar,
    fst,
    createPerValidatorStates,
    createPerValidatorStateCh,
    createPerValidatorStateChs,
    deposit, distributeRewards, distributeRewardDeltas,
    perActiveValidatorPosVaultsCh,
    transferFromBlockSender,
    rs(`rho:registry:insertSigned:secp256k1`),
    posId(`rho:rchain:deployerId`),
    uriOut,
    out(`rho:io:stdout`)
in {
  registryLookup!(`rho:rchain:revVault`, *revVaultCh) |
  registryLookup!(`rho:lang:listOps`, *listOpsCh) |
  for (@(_, RevVault) <- revVaultCh;
       @(_, ListOps)  <- listOpsCh) {
    new posRevAddressCh,
        posAuthKeyCh,
        posVaultCh,
        initialActiveCh
    in {
      @RevVault!("deployerAuthKey", *posId, *posAuthKeyCh) |
      getCurrentUserAddress!(*posId, *posRevAddressCh) |
      new rangeCh,
          makeVault
      in {
        contract makeVault(_, returnCh) = {
          new unf,
              revAddressCh,
              vaultCh
          in {
            revAddressOps!("fromUnforgeable", *unf, *revAddressCh) |
            for (@revAddress <- revAddressCh) {
              @RevVault!("findOrCreate", revAddress, *vaultCh) |
              for (@(true, vault) <- vaultCh) {
                returnCh!((*unf, revAddress, vault))
              }
            }
          }
        } |
        @ListOps!("range", 0, $$numberOfActiveValidators$$, *rangeCh) |
        for (@range <- rangeCh) {
          @ListOps!("parMap", range, *makeVault, *perActiveValidatorPosVaultsCh)
        }
      } |
      for (@posRevAddress <- posRevAddressCh;
           @posAuthKey    <- posAuthKeyCh) {
        @RevVault!("findOrCreate", posRevAddress, *posVaultCh) |
        pickActiveValidators!($$initialBonds$$, {}, *initialActiveCh) |
        for (@(true, posVault) <- posVaultCh;
             @initialActive    <- initialActiveCh) {
          new stateCh,
              vStateCh
          in {
            new tmpCh in {
              createPerValidatorStateChs!(initialActive, *tmpCh) |
              for (@vStateChsMap <- tmpCh) {
                // State structure:
                // pendingRewards   : Map[PublickKey, Int] - are accummulated by calling "chargeDeploy"
                // committedRewards : Map[PublickKey, Int] - are moved from pendingRewards at each closeBlock
                // activeValidators : List[PublicKey] - the active validators
                // withdrawers      : Map[PublicKey, Int] - the validators willing to withdraw and the blocknumber when their quarantine ends
                //                                     This is the beggining of the next epoch after their withdrawal + quarantineLength
                // allBonds         : Map[PublickKey, Int] - each validator stake
                stateCh!({
                  "pendingRewards":{},
                  "committedRewards":{},
                  "activeValidators":initialActive,
                  "withdrawers":{},
                  "randomImages":{},
                  "randomNumbers":{},
                  "allBonds":$$initialBonds$$,
                  "stateChs":vStateChsMap
                })
              }
            } ||
            // Initializes per active validator states on their personal update channels.
            for (@state <<- stateCh) {
              createPerValidatorStates!(state, state.get("activeValidators"))
            } |
            contract PoS(@"getBonds", returnCh) = {
              for (@state <<- stateCh) {
                returnCh!(state.get("allBonds"))
              }
            } |
            contract PoS(@"getActiveValidators", returnCh) = {
              for (@state <<- stateCh) {
                returnCh!(state.get("activeValidators"))
              }
            } |
            contract PoS(@"getActiveValidatorVaults", returnCh) = {
              for (@vaults <<- perActiveValidatorPosVaultsCh) {
                returnCh!(vaults)
              }
            } |
            /**
             * Returns a Map[PublicKey, Int] containing the rewards accumulated for each validator.
             * The returned map contains only the committed rewards after the last closeBlock
             */
            contract PoS(@"getRewards", returnCh) = {
              for (@state <<- stateCh) {
                returnCh!(state.get("committedRewards"))
              }
            } |
            // Allows a user to become a bonded validator.
            contract PoS(@"bond", @deployerId, @amount, returnCh) = {
              new userCh, depositCh, processCh,
                  getBlockData(`rho:block:data`), blockDataCh
              in {
                // Peeks at global state and current block data to access and update the block sender's state.
                for (@state <<- stateCh) {
                  getBlockData!(*blockDataCh) |
                  for (_, _, @sender <- blockDataCh) {
                    runMVar!(state.get("stateChs").get(sender), *processCh, *returnCh)
                  }
                } |
                getUser!(deployerId, *userCh) |
                for (@vState, resultCh <- processCh;
                     @userPk           <- userCh) {
                  if (vState.get("allBonds").contains(userPk)) {
                    resultCh!(vState, (false, "Public key is already bonded."))
                  } else if (amount < $$minimumBond$$) {
                    resultCh!(vState, (false, "Bond is less than minimum!"))
                  } else if (amount > $$maximumBond$$) {
                    resultCh!(vState, (false, "Bond is greater than maximum!"))
                  } else {
                    deposit!(deployerId, amount, vState.get("activeValidators"), *depositCh) |
                    for (@depositResult <- depositCh) {
                      match depositResult {
                        (true, _) => {
                          // Updates validator's local state.
                          // TODO: consolidate all local bond map changes before choosing active validators.
                          resultCh!(
                            vState.set("allBonds", vState.get("allBonds").set(userPk,amount)),
                            depositResult
                          )
                        }
                        (false, errorMsg) => {
                          resultCh!(vState, (false, "Bond deposit failed: " ++ errorMsg))
                        }
                      }
                    }
                  }
                }
              }
            } |
            // TODO: explain changes
            contract PoS(@"withdraw", @deployerId, returnCh) = {
              new userCh, processCh,
                  getBlockData(`rho:block:data`), blockDataCh
              in {
                // Peeks at global state and current block data to access and update the block sender's state.
                for (@state <<- stateCh) {
                  getBlockData!(*blockDataCh) |
                  for (@blockNumber, _, @sender <- blockDataCh) {
                    runMVar!(state.get("stateChs").get(sender), *processCh, *returnCh)
                    getUser!(deployerId, *userCh) |
                    for (@vState, resultCh <- processCh;
                         @userPk           <- userCh) {
                      if (state.get("allBonds").contains(userPk)) {
                        // Quarantine period goes into effect at the beginning of the next epoch.
                        // TODO: consolidate all local withdrawers map changes before choosing active validators.
                        resultCh!(
                          vState.set("withdrawers",
                                    vState.get("withdrawers")
                                         .set(userPk,
                                           blockNumber + $$quarantineLength$$ + $$epochLength$$ - (blockNumber % $$epochLength$$))),
                         (true, Nil))
                      } else {
                       resultCh!(vState, (false, "User is not bonded"))
                      }
                    }
                  }
                }
              }
            } |
            // TODO: explain charge deploy
            new currentDeployerData in {
              contract PoS(@"chargeDeploy", @deployerId, @amount, return) = {
                new depositCh in {
                  for (@state <<- stateCh) {
                    deposit!(deployerId, amount, state.get("activeValidators"), *depositCh) |
                    for (@depositResult <- depositCh){
                      match depositResult {
                        (true, _) => {
                          currentDeployerData!((deployerId, amount)) |
                          return!(depositResult) |
                          out!("chargeDeploy") // TODO: remove
                        }
                        (_, errorMessage) => {
                          return!((false, "Deploy payment failed: " ++ errorMessage))
                        }
                      }
                    }
                  }
                }
              } |
              contract transferFromBlockSender(@sender, @deployerRevAddress, @refundAmount, returnCh) = {
                new indexSender,
                    unfAuthKeyCh
                in {
                  for (@state <<- stateCh) {
                    for (@vaults <<- perActiveValidatorPosVaultsCh) {
                      @ListOps!("indexOf", state.get("activeValidators"), sender, *indexSender) |
                      for (@idx <- indexSender) {
                        if (idx == -1) {
                          returnCh!((false, "Sender is not an active validator"))
                        } else {
                          match vaults.nth(idx) {
                            (unf, _, activeValidatorVault) => {
                              @RevVault!("unforgeableAuthKey", unf, *unfAuthKeyCh) |
                              for (@authKey <- unfAuthKeyCh) {
                                @activeValidatorVault!("transfer", deployerRevAddress, refundAmount, authKey, *returnCh) |
                                out!("transferFromBlockSender") // TODO: remove
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } |
              // Note: under no circumstances should this method be merged as is.
              //       this method, along with "chargeDeploy", "closeBlock", and "slash"
              //       must be made private, as they're only used in the protocol.
              contract PoS(@"refundDeploy", @refundAmount, return) = {
                for (@(deployerId, initialPaymentAmount) <- currentDeployerData){
                  new revAddressCh in {
                    revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
                    for (@deployerRevAddress <- revAddressCh){
                      new transferCh,
                          getBlockData(`rho:block:data`),
                          blockDataCh
                      in {
                        getBlockData!(*blockDataCh) |
                        for (_, _, @sender <- blockDataCh) {
                          // Block sender refunds deployer if overcharged.
                          transferFromBlockSender!(sender, deployerRevAddress, refundAmount, *transferCh) |
                          // Once refund is finished, rewards are distributed to all active validators.
                          for (@transferResult <- transferCh){
                            match transferResult {
                              (true, _) => {
                                // Get bonds and active validators, then send rewards delta map on sender's.
                                for (@state <<- stateCh) {
                                  for (@vState <- @{state.get("stateChs").get(sender)}) {
                                    // Stake-weighted reward distribution, updates sender's local state.
                                    distributeRewards!(
                                      initialPaymentAmount - refundAmount,
                                      vState.get("activeValidators"),
                                      vState.get("allBonds"),
                                      vState.get("pendingRewards"),
                                      state.get("stateChs").get(sender)
                                    ) |
                                    return!((true, Nil)) |
                                    out!(["refundDeploy", sender]) // TODO: remove
                                  }
                                }
                              }
                              (_, errorMessage) => {
                                return!((false, "(Bug found) Deploy refund failed: " ++ errorMessage))
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } |
            // TODO: should be postponed to epoch change where all slashed validator funds should be
            // TODO: redistributed to the other (non-slashed) current active validators
            contract PoS(@"slash", @deployerId, @blockHash, returnCh) = {
              new userCh, invalidBlocksCh, doSlashCh,
                  getInvalidBlocks(`rho:casper:invalidBlocks`),
                  getBlockData(`rho:block:data`), blockDataCh
              in {
                getInvalidBlocks!(*invalidBlocksCh) |
                getUser!(deployerId, *userCh) |
                // Peeks at global state and current block data to access and update the block sender's state.
                for (@state <<- stateCh) {
                  getBlockData!(*blockDataCh) |
                  for (_, _, @sender <- blockDataCh) {
                    runMVar!(state.get("stateChs").get(sender), *doSlashCh, *returnCh)
                  }
                } |
                for (@invalidBlocks         <- invalidBlocksCh;
                     @userPk                <- userCh;
                     @vState, slashResultCh <- doSlashCh) {
                  new toBeSlashed in {
                    toBeSlashed!(invalidBlocks.getOrElse(blockHash, userPk)) |
                    for (@validator <- toBeSlashed) {
                      // TODO: Transfer to coop wallet instead of just simply setting bonds to 0
                      slashResultCh!(
                        vState.set("pendingRewards", vState.get("pendingRewards").set(validator, 0))
                             .set("committedRewards", vState.get("committedRewards").set(validator, 0))
                             .set("allBonds", vState.get("allBonds").set(validator, 0)),
                        true)
                    }
                  }
                }
              }
            } |
            // Nothing more to do if epoch does not change.
            // Update state & updateMap if epoch changes.
            contract PoS(@"closeBlock", ackCh) = {
              new accumulateDeposits,
                  commitRewards,
                  removeQuarantinedWithdrawers,
                  payWithdrawers
              in {
                new blockDataCh, mvarProcessCh,
                    getBlockData(`rho:block:data`),
                    accDepositsDoneCh, commitRewardsCh,
                    newValidatorsCh, removeQuarantinedCh,
                    paymentDoneCh
                in {
                  getBlockData!(*blockDataCh) |
                  for (@blockNumber, _, @sender <- blockDataCh) {
                    // TODO: accumulate sender's updates
                    if (blockNumber % $$epochLength$$ == 0) {
                      // TODO: need to update validators' local states
                      // Updating the global state.
                      // TODO: merge all local state changes
                      runMVar!(*stateCh, *mvarProcessCh, *ackCh) |
                      for (@state, mvarResultCh <- mvarProcessCh) {
                        accumulateDeposits!(
                          state.get("activeValidators"),
                          sender,
                          *accDepositsDoneCh) |
                        for (_ <- accDepositsDoneCh) {
                          // TODO: needs to be changed to accumulate from sender's state channel
                          //runMVar!(*vStateCh, *mvarProcessCh, *ackCh) |
                          //for (@update, mvarResultCh <- mvarProcessCh) {
                          commitRewards!(
                            Sum over all val: update.get(val).get("reward"),
                            state.get("committedRewards"),
                            *commitRewardsCh) |
                          // Chooses active validators for the next epoch.
                          pickActiveValidators!(
                            state.get("allBonds"),
                            state.get("withdrawers"),
                            *newValidatorsCh) |
                          // Calculates payout for withdrawing validators who have finished their quarantine period.
                          removeQuarantinedWithdrawers!(
                            blockNumber,
                            state.get("allBonds"),
                            state.get("withdrawers"),
                            committedRewards,
                            *removeQuarantinedCh) |
                          // Pays withdrawing validators.
                          for (@newValidators                                    <- newValidatorsCh;
                               @(payments, newBonds, newWithdrawers, newRewards) <- removeQuarantinedCh) {
                            payWithdrawers!(payments, *paymentDoneCh) |
                            for (_ <- paymentDoneCh) {
                              // Updates state with new maps.
                              mvarResultCh!({
                                "activeValidators":newValidators,
                                "allBonds":newBonds,
                                "committedRewards":newRewards,
                                "pendingRewards":{},
                                "randomImages":{},
                                "randomNumbers":{},
                                "withdrawers":newWithdrawers
                                },
                                Nil)
                            }
                          }
                        }
                      }
                    }
                  }
                } |
                new moveFunds in {
                  contract moveFunds(@(unf, _, vault), returnCh) = {
                    new balanceCh, unfAuthKeyCh, transferDoneCh in {
                      @vault!("balance", *balanceCh) |
                      for (@balance <- balanceCh) {
                        if (balance > 0) {
                          @RevVault!("unforgeableAuthKey", unf, *unfAuthKeyCh) |
                          for (@authKey <- unfAuthKeyCh) {
                            @vault!("transfer", posRevAddress, balance, authKey, *transferDoneCh) |
                            for (@(true, Nil) <- transferDoneCh) {
                              returnCh!(true)
                            }
                          }
                        } else {
                          returnCh!(true)
                        }
                      }
                    }
                  } |
                  contract accumulateDeposits(@activeValidators, @sender, ackCh) = {
                    new indexCh in{
                      @ListOps!("indexOf", activeValidators, sender, *indexCh) |
                      for (@idx <- indexCh) {
                        if (idx == -1) {
                          ackCh!(false)
                        } else {
                          for (@vaults <<- perActiveValidatorPosVaultsCh) {
                            moveFunds!(vaults.nth(idx), *ackCh)
                          }
                        }
                      }
                    }
                  }
                } |
                new payWithdrawer in {
                  contract payWithdrawer(@(pk, amount), returnCh) = {
                    new vaultCh,
                        revAddressCh
                    in {
                      revAddressOps!("fromPublicKey", pk, *revAddressCh) |
                      for (@toRevAddress <- revAddressCh) {
                        @posVault!("transfer", toRevAddress, amount, posAuthKey, *returnCh)
                      }
                    }
                  } |
                  contract payWithdrawers(@payments, ackCh) = {
                    @ListOps!("unorderedParMap", payments, *payWithdrawer, *ackCh)
                  }
                } |
                new commitReward in {
                  contract commitReward(@(pk, pending), @acc, resultCh) = {
                    resultCh!(acc.set(pk, acc.getOrElse(pk, 0) + pending))
                  } |
                  contract commitRewards(@pendingRewards, @rewards, newRewardsCh) = {
                    @ListOps!("fold", pendingRewards.toList(), rewards, *commitReward, *newRewardsCh)
                  }
                } |
                contract removeQuarantinedWithdrawers(@currentBlockNumber, @allBonds, @withdrawers, @rewards, returnCh) = {
                  new quarantinedValidatorsCh,
                      validatorsToWithdrawListCh,
                      isQuarantineFinished,
                      notWithdrawn,
                      newBondsListCh,
                      newWithdrawersListCh,
                      newRewardsListCh,
                      paymentsCh,
                      computePay
                  in {
                    @ListOps!("filter", withdrawers.toList(), *isQuarantineFinished, *quarantinedValidatorsCh) |
                    for (@quarantinedValidators <- quarantinedValidatorsCh) {
                      @ListOps!("map", quarantinedValidators, *fst, *validatorsToWithdrawListCh) |
                      for (@validatorsToWithdrawList <- validatorsToWithdrawListCh) {
                        @ListOps!("map", validatorsToWithdrawList, *computePay, *paymentsCh) |
                        contract computePay(@pk, resultCh) = {
                          resultCh!((pk, allBonds.get(pk) + rewards.getOrElse(pk, 0)))
                        } |
                        match validatorsToWithdrawList.toSet() {
                          validatorsToWithdrawSet => {
                            @ListOps!("filter", allBonds.toList(), *notWithdrawn, *newBondsListCh) |
                            @ListOps!("filter", withdrawers.toList(), *notWithdrawn, *newWithdrawersListCh) |
                            @ListOps!("filter", rewards.toList(), *notWithdrawn, *newRewardsListCh) |
                            for (@newWithdrawersList <- newWithdrawersListCh;
                                 @newBondsList       <- newBondsListCh;
                                 @newRewardsList     <- newRewardsListCh;
                                 @payments           <- paymentsCh) {
                              returnCh!((payments, newBondsList.toMap(), newWithdrawersList.toMap(), newRewardsList.toMap()))
                            } |
                            contract notWithdrawn(@(pk, _), resultCh) = {
                              resultCh!(not validatorsToWithdrawSet.contains(pk))
                            }
                          }
                        }
                      }
                    } |
                    contract isQuarantineFinished(@(_, quarantineDoneblockNumber), resultCh) = {
                      resultCh!(currentBlockNumber >= quarantineDoneblockNumber)
                    }
                  }
                }
              }
            } |
            // TODO: resolve state update (can this be postponed to epoch change?)
            contract PoS(@"commitRandomImage", @deployerId, @hash, ackCh) = {
              new userCh, mvarCh in {
                getUser!(deployerId, *userCh) |
                runMVar!(*stateCh, *mvarCh, *ackCh) |
                for (@validator       <- userCh;
                     @state, resultCh <- mvarCh) {
                  if (state.get("randomImages").contains(validator)) {
                    resultCh!(state, (false, "Image already committed"))
                  } else {
                    resultCh!(state.set("randomImages", state.get("randomImages").set(validator, hash)), true)
                  }
                }
              }
            } |
            // TODO: resolve state update (can this be postponed to epoch change?)
            contract PoS(@"revealRandom", @deployerId, @random, ackCh) = {
              new userCh, mvarCh, computeHash(`rho:crypto:keccak256Hash`), hashCh in {
                getUser!(deployerId, *userCh) |
                runMVar!(*stateCh, *mvarCh, *ackCh) |
                computeHash!(random, *hashCh) |
                for (@validator       <- userCh;
                     @state, resultCh <- mvarCh;
                     @hash            <- hashCh) {
                  if (state.get("randomImages").contains(validator)) {
                    if (hash == state.get("randomImages").get(validator)) {
                      resultCh!(
                        state.set("randomNumbers",
                          state.get("randomNumbers").set(validator, random)),
                        true)
                    } else {
                      resultCh!(state, (false, "Previously committed image doesn't match the random number"))
                    }
                  } else {
                    resultCh!(state, (false, "Previously committed random image not found"))
                  }
                }
              }
            }
          }
        } |
        contract deposit(@deployerId, @amount, @activeValidators, returnCh) = {
          new vaultCh,
              revAddressCh,
              indexSender,
              getBlockData(`rho:block:data`),
              blockDataCh,
              authKeyCh
          in {
            @RevVault!("deployerAuthKey", deployerId, *authKeyCh) |
            revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
            for (@authKey        <- authKeyCh;
                 @fromRevAddress <- revAddressCh) {
              @RevVault!("findOrCreate", fromRevAddress, *vaultCh) |
              getBlockData!(*blockDataCh) |
              for (@(true, fromVault) <- vaultCh;
                   _, _, @sender      <- blockDataCh) {
                @ListOps!("indexOf", activeValidators, sender, *indexSender) |
                for (@idx <- indexSender) {
                  for (@vaults <<- perActiveValidatorPosVaultsCh) {
                    if (idx == -1) {
                      returnCh!((false, "Sender is not an active validator"))
                    } else {
                      match vaults.nth(idx) {
                        (_, activeValidatorVault, _) => {
                          @fromVault!("transfer", activeValidatorVault, amount, authKey, *returnCh)
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } |
        // Computes rewards delta and adds to current map.
        contract distributeRewards(@amount, @activeValidators, @bonds, @originalRewards, returnCh) = {
          new rewardsDeltaCh,
              computeMergeMap
          in {
            // Computes active validator rewards delta map.
            distributeRewardDeltas!(amount, activeValidators, bonds, *rewardsDeltaCh) |
            for (@rewardsDelta <- rewardsDeltaCh) {
              // Add corresponding values of rewardsDela map to the originalRewards map.
              @ListOps!("fold", rewardsDelta.toList(), originalRewards, *computeMergeMap, *returnCh) |
              contract computeMergeMap(@(pk, rewardDelta), @acc, resultCh) = {
                resultCh!(acc.set(pk, acc.getOrElse(pk, 0) + rewardDelta))
              }
            }
          }
        } |
        // TODO: move back to distributeRewards ^^^
        contract distributeRewardDeltas(@amount, @activeValidators, @bonds, returnCh) = {
          new computeSum,
              totalActiveStakeCh,
              computeDelta
          in {
            // Computes total stake of active validators.
            @ListOps!("fold", activeValidators, 0, *computeSum, *totalActiveStakeCh) |
            contract computeSum(@pk, @acc, resultCh) = {
              resultCh!(acc + bonds.get(pk))
            } |
            // Computes the rewards delta for each active validator.
            for (@totalActiveStake <- totalActiveStakeCh) {
              @ListOps!("fold", activeValidators, {}, *computeDelta, *returnCh) |
              // Stake-weighted rewards delta map.
              contract computeDelta(@pk, @acc, resultCh) = {
                resultCh!(acc.set(pk, (amount * bonds.get(pk)) / totalActiveStake))
              }
            }
          }
        }
      } |
      contract createPerValidatorStateChs(@activeList, retCh) = {
        new resCh in {
          @ListOps!("parMap", activeList, *createValidatorUpdateCh, *resCh) |
          for (@list <- resCh) {
            retCh!(list.toMap())
          }
        }
      } |
      // Creates unforgeable update channel for each active validator.
      // Should a validator's update channel change each epoch?
      contract createPerValidatorStateCh(@validator, retCh) = {
        new updateCh in {
          retCh!((validator, *updateCh))
        }
      } |
      // Replicates global state onto each validator's personal state channel.
      for (@state <<- stateCh) {
        // map.remove is not implemented yet :(
        // TODO: change to map.remove(validator) once implemented
        new stateNoUpdateCh in {
          stateNoUpdateCh!({
            "pendingRewards":state.get("pendingRewards"),
            "committedRewards":state.get("committedRewards"),
            "activeValidators":state.get("activeValidators"),
            "withdrawers":state.get("withdrawers"),
            "randomImages":state.get("randomImages"),
            "randomNumbers":state.get("randomNumbers"),
            "allBonds":state.get("allBonds")
          }) |
          for (@stateNoUpdate <- stateNoUpdateCh) {
            contract createPerValidatorStates(@state, @activeList) = {
              match activeList {
                [h ...t] => {
                  @{state.get("updateChs").get(h)}!(stateNoUpdate) |
                  createPerValidatorStates!(state, t)
                }
                _ => Nil
              }
            }
          }
        }
      } |
      contract runMVar(varCh, processCh, returnCh) = {
        new resultCh in {
          for (@v <- varCh) {
            processCh!(v, *resultCh) |
            for (@newV, @result <- resultCh) {
              varCh!(newV) |
              returnCh!(result)
            }
          }
        }
      } |
      contract fst(@(first, _), resultCh) = {
        resultCh!(first)
      } |
      contract getUser(@deployerId, returnCh) = {
        new deployerIdOps(`rho:rchain:deployerId:ops`) in {
          deployerIdOps!("pubKeyBytes", deployerId, *returnCh)
        }
      } |
      contract getCurrentUserAddress(@deployerId, returnCh) = {
        new userCh in {
          getUser!(deployerId, *userCh) |
          for (@userPk <- userCh) {
            revAddressOps!("fromPublicKey", userPk, *returnCh)
          }
        }
      } |
      contract pickActiveValidators(@allBonds, @withdrawers, returnCh) = {
        new availableValidatorsCh, isAvailable, pksCh in {
          @ListOps!("filter", allBonds.toList(), *isAvailable, *availableValidatorsCh) |
          contract isAvailable(@(pk, _), resultCh) = {
            resultCh!(not withdrawers.contains(pk))
          } |
          for (@availableValidators <- availableValidatorsCh) {
            @ListOps!("map", availableValidators, *fst, *pksCh) |
            for (@pks <- pksCh) {
              // TODO: Randomly select 100 active validators once we have on-chain randomness
              returnCh!(pks.take($$numberOfActiveValidators$$))
            }
          }
        }
      }
    }
  } |
  rs!(
    "047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f".hexToBytes(),
    (9223372036854775807, bundle+{*PoS}),
    "3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f".hexToBytes(),
    *uriOut)
}
