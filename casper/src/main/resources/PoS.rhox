// Rholang macro parameters:
// minimumBond - the minimum bond allowed by the PoS
// maximumBond - the maximum bond allowed by PoS
// initialBonds - the initial bonds map
// epochLength - the length of the validation epoch in blocks
// quarantineLength - the length of the quarantine time in blocks

/*
 The table below describes the required computations and their dependencies

 No. | Dependency | Computation method | Result
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
 1.  |            | given              | sk = a9585a0687761139ab3587a4938fb5ab9fcba675c79fefba889859674046d4a5
 2.  |            | given              | timestamp = 1559156420651
 3.  |            | lastNonce          | nonce = 9223372036854775807
 4.  | 1,         | secp256k1          | pk = 047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f
 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b)
 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xa32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b) })
 7.  | 6,         | protobuf           | toSign = 2a40aa013d0a0d2a0b10feffffffffffffffff010a2c5a2a0a263a240a220a20a32c1649f1700469f125ea85f9c2a220072e593ae617213782d738e389639d3b1001
 8.  | 7, 1,      | secp256k1          | sig = 3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f
 9.  | 4,         | registry           | uri = rho:id:m3xk7h8r54dtqtwsrnxqzhe81baswey66nzw6m533nyd45ptyoybqr
 ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
*/

new PoS,
    registryLookup(`rho:registry:lookup`),
    revAddressOps(`rho:rev:address`),
    revVaultCh, listOpsCh,
    getUser,
    getCurrentUserAddress,
    pickActiveValidators,
    runMVar,
    fst,
    deposit, distributeRewards,
    perActiveValidatorPosVaultsCh,
    transferFromBlockSender,
    rs(`rho:registry:insertSigned:secp256k1`),
    posId(`rho:rchain:deployerId`),
    PendingRewards, MergeIntMaps, treeHashMapCh,
    sysAuthTokenOps(`sys:authToken:ops`),
    multiSigRevVaultCh, coopWalletCh,
    uriOut
in {
  // Simultaneously retrieves RevVault, ListOps, TreeHashMap, and MultiSigRevVault contracts from the registry.
  registryLookup!(`rho:rchain:revVault`, *revVaultCh) |
  registryLookup!(`rho:lang:listOps`, *listOpsCh) |
  registryLookup!(`rho:lang:treeHashMap`, *treeHashMapCh) |
  registryLookup!(`rho:rchain:multiSigRevVault`, *multiSigRevVaultCh) |
  for (@(_, RevVault)         <- revVaultCh;
       @(_, ListOps)          <- listOpsCh;
       TreeHashMap            <- treeHashMapCh;
       @(_, MultiSigRevVault) <- multiSigRevVaultCh) {
    new posRevAddressCh, posAuthKeyCh, posVaultCh,
        initialActiveCh, pendingRewardsMapCh
    in {
      // Creates a Rev vault for each active validator, in parallel.
      new rangeCh, makeVault in {
        contract makeVault(_, returnCh) = {
          new unf, revAddressCh, vaultCh in {
            revAddressOps!("fromUnforgeable", *unf, *revAddressCh) |
            for (@revAddress <- revAddressCh) {
              @RevVault!("findOrCreate", revAddress, *vaultCh) |
              for (@(true, vault) <- vaultCh) {
                returnCh!((*unf, revAddress, vault))
              }
            }
          }
        } |
        @ListOps!("range", 0, $$numberOfActiveValidators$$, *rangeCh) |
        for (@range <- rangeCh) {
          @ListOps!("parMap", range, *makeVault, *perActiveValidatorPosVaultsCh)
        }
      } |
      // Creates the auth key and Rev vault associated with the PoS contract.
      new posPkCh in {
        @RevVault!("deployerAuthKey", *posId, *posAuthKeyCh) |
        getUser!(*posId, *posPkCh) |
        for (@posPk <- posPkCh) {
          revAddressOps!("fromPublicKey", posPk, *posRevAddressCh) |
          // Creates Coop multisig vault for slashed funds.
          // (false, errorMsg) xor (true, (multiSigVault, revAddress, revVault)) are returned on coopWalletCh.
          // TODO: supply real publicKeys, unsealers, and quorumSize
          @MultiSigRevVault!("create", [posPk], [], 1, *coopWalletCh)
        }
      } |
      for (@posRevAddress      <- posRevAddressCh;
           @posAuthKey         <- posAuthKeyCh;
           @(true, coopWallet) <- coopWalletCh) {
        @RevVault!("findOrCreate", posRevAddress, *posVaultCh) |
        // Selects the initial active validators.
        pickActiveValidators!($$initialBonds$$, {}, *initialActiveCh) |
        // Initializes pending rewards TreeHashMap.
        // - each key in pending rewards state is Map[PublicKey, Int] accumulated by calling "refundDeploy".
        TreeHashMap!("init", 3, *pendingRewardsMapCh) |
        for (@(true, posVault)  <- posVaultCh;
             @initialActive     <- initialActiveCh;
             @pendingRewardsMap <- pendingRewardsMapCh) {
          new stateCh, pendingRewardsInitializedCh in {
            // Initializes empty pending rewards state for each validator.
            // - states must be initialized to prevent conflicts during "set" (only lookup can be conflict free)
            PendingRewards!("init", initialActive, *pendingRewardsInitializedCh) |
            for (_ <- pendingRewardsInitializedCh) {
              // Initializes PoS state structure.
              stateCh!({
                // Map[PublicKey, Int] - each validator stake
                "allBonds"        : $$initialBonds$$,
                // List[PublicKey]     - the active validators
                "activeValidators": initialActive,
                // Map[PublicKey, Int] - are moved from pendingRewards on epoch change or slashing
                "committedRewards": {},
                // Map[PublicKey, Int] - the validators wishing to withdraw and the blocknumber when their quarantine ends
                //                       This begins at the start of the next epoch + quarantineLength.
                "withdrawers"     : {},
                "randomImages"    : {},
                "randomNumbers"   : {},
              })
            } |
            // Peeks at bonds map.
            contract PoS(@"getBonds", returnCh) = {
              for (@state <<- stateCh) {
                returnCh!(state.get("allBonds"))
              }
            } |
            // Peeks at active validator list.
            contract PoS(@"getActiveValidators", returnCh) = {
              for (@state <<- stateCh) {
                returnCh!(state.get("activeValidators"))
              }
            } |
            // Peeks at active validator vaults.
            contract PoS(@"getActiveValidatorVaults", returnCh) = {
              for (@vaults <<- perActiveValidatorPosVaultsCh) {
                returnCh!(vaults)
              }
            } |
            // Peeks at the accumulated rewards map, i.e. "committed rewards".
            // The returned map contains only the rewards committed up to the last closeBlock.
            contract PoS(@"getRewards", returnCh) = {
              for (@state <<- stateCh) {
                returnCh!(state.get("committedRewards"))
              }
            } |
            // Exposes Coop multisig vault on resultCh.
            contract PoS(@"getCoopWallet", returnCh) = {
              for (@(_, coopWallet) <<- coopWalletCh) {
                returnCh!(coopWallet)
              }
            } |
            // Public method allowing users to bond and become validators.
            contract PoS(@"bond", @deployerId, @amount, returnCh) = {
              new userCh, depositCh,
                  processCh
              in {
                runMVar!(*stateCh, *processCh, *returnCh) |
                getUser!(deployerId, *userCh) |
                for (@state, resultCh <- processCh;
                     @userPk          <- userCh) {
                  if (state.get("allBonds").contains(userPk)) {
                    resultCh!(state, (false, "Public key is already bonded."))
                  } else if (amount < $$minimumBond$$) {
                    resultCh!(state, (false, "Bond is less than minimum!"))
                  } else if (amount > $$maximumBond$$) {
                    resultCh!(state, (false, "Bond is greater than maximum!"))
                  } else {
                    deposit!(deployerId, amount, state.get("activeValidators"), *depositCh) |
                    for (@depositResult <- depositCh) {
                      match depositResult {
                        (true, _) => {
                          resultCh!(state.set("allBonds",state.get("allBonds").set(userPk,amount)),
                                    depositResult)
                        }
                        (false, errorMsg) => {
                          resultCh!(state, (false, "Bond deposit failed: " ++ errorMsg))
                        }
                      }
                    }
                  }
                }
              }
            } |
            // Public method allowing validators to withdraw their bonded and accumulated funds.
            contract PoS(@"withdraw", @deployerId, returnCh) = {
              new userCh, processCh, blockDataCh,
                  getBlockData(`rho:block:data`)
              in {
                // Consumes state and updates withdrawers map.
                runMVar!(*stateCh, *processCh, *returnCh) |
                getBlockData!(*blockDataCh) |
                getUser!(deployerId, *userCh) |
                for (@state, resultCh   <- processCh;
                     @userPk            <- userCh;
                     @blockNumber, _, _ <- blockDataCh) {
                  if (state.get("allBonds").contains(userPk)) {
                    // The withdwal goes into effect at the sart of the next epoch.
                    resultCh!(
                      state.set("withdrawers",
                                state.get("withdrawers")
                                     .set(userPk,
                                       $$quarantineLength$$ + $$epochLength$$ * (1 + blockNumber / $$epochLength$$))),
                      (true, Nil))
                  } else {
                    resultCh!(state, (false, "User is not bonded"))
                  }
                }
              }
            } |
            // Private method which charges a deployer for a deploy.
            // Deployer's funds are deposited into the block sender's vault.
            new currentDeployerData in {
              contract PoS(@"chargeDeploy", @deployerId, @amount, @sysAuthToken, return) = {
                new isValidTokenCh in {
                  sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                  for (@isValid <- isValidTokenCh) {
                    if (isValid) {
                      new depositCh in {
                        for (@state <<- stateCh) {
                          deposit!(deployerId, amount, state.get("activeValidators"), *depositCh) |
                          for (@depositResult <- depositCh){
                            match depositResult {
                              (true, _) => {
                                currentDeployerData!((deployerId, amount)) |
                                return!(depositResult)
                              }
                              (_, errorMessage) => {
                                return!((false, "Deploy payment failed: " ++ errorMessage))
                              }
                            }
                          }
                        }
                      }
                    } else {
                      return!((false, "Invalid system auth token"))
                    }
                  }
                }
              } |
              // Transfer (from sender to deployer) called in refundDeploy.
              contract transferFromBlockSender(@deployerRevAddress, @sender, @refundAmount, returnCh) = {
                new indexSender, tmpCh, unfAuthKeyCh in {
                  for (@state <<- stateCh) {
                    @ListOps!("indexOf", state.get("activeValidators"), sender, *indexSender) |
                    for (@idx <- indexSender) {
                      for (@vaults <<- perActiveValidatorPosVaultsCh) {
                        if (idx == -1) {
                          returnCh!((false, "Sender is not an active validator"))
                        } else {
                          match vaults.nth(idx) {
                            (unf, _, activeValidatorVault) => {
                              @RevVault!("unforgeableAuthKey", unf, *unfAuthKeyCh) |
                              for (@authKey <- unfAuthKeyCh) {
                                @activeValidatorVault!("transfer", deployerRevAddress, refundAmount, authKey, *returnCh)
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } |
              // Private method which refunds a deployer if too much was charged in chargeDeploy.
              // Funds are transferred from the block sender's vault to the deployer.
              contract PoS(@"refundDeploy", @refundAmount, @sysAuthToken, return) = {
                new isValidTokenCh in {
                  sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                  for (@isValid <- isValidTokenCh) {
                    if (isValid) {
                      for(@(deployerId, initialPaymentAmount) <- currentDeployerData){
                        new revAddressCh in {
                          revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
                          for(@deployerRevAddress <- revAddressCh){
                            new transferCh in {
                              transferFromBlockSender!(deployerRevAddress, refundAmount, *transferCh) |
                              for(@transferResult <- transferCh){
                                match transferResult {
                                  (true, _) => {
                                    new newRewardsCh, pendingUpdatedCh, blockDataCh,
                                        getBlockData(`rho:block:data`)
                                    in {
                                      for (@state <<- stateCh) {
                                        distributeRewards!(
                                          initialPaymentAmount - refundAmount,
                                          state.get("activeValidators"),
                                          state.get("allBonds"),
                                          *newRewardsCh)
                                      } |
                                      getBlockData!(*blockDataCh) |
                                      for(@newRewards <- newRewardsCh;
                                          _, _, @sender <- blockDataCh) {
                                        // Add new pending rewards to validator pending rewards state
                                        PendingRewards!("append", sender, newRewards, *pendingUpdatedCh) |
                                        for (_ <- pendingUpdatedCh) {
                                          return!((true, Nil))
                                        }
                                      }
                                    }
                                  }
                                  (_, errorMessage) => {
                                    return!((false, "(Bug found) Deploy refund failed: " ++ errorMessage))
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      return!((false, "Invalid system auth token"))
                    }
                  }
                }
              }
            } |
            new accumulateDeposits, commitRewards in {
              // Private method which transfers all of a validator's pending and committed rewards + bond to the Coop wallet.
              contract PoS(@"slash", @deployerId, @blockHash, @sysAuthToken, returnCh) = {
                new isValidTokenCh in {
                  sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                  for (@isValid <- isValidTokenCh) {
                    if (isValid) {
                      new userCh, invalidBlocksCh, doSlashCh,
                          getInvalidBlocks(`rho:casper:invalidBlocks`)
                      in {
                        getInvalidBlocks!(*invalidBlocksCh) |
                        getUser!(deployerId, *userCh) |
                        runMVar!(*stateCh, *doSlashCh, *returnCh) |
                        for (@invalidBlocks        <- invalidBlocksCh;
                             @userPk               <- userCh;
                             @state, slashResultCh <- doSlashCh) {
                          match coopWallet {
                            (_, coopRevAddress, _) => {
                              new toBeSlashed, valBondCh, valRewardsCh in {
                                // accumulateDeposits ; commitRewards ; transfer slashed funds to Coop ; update state
                                // Sends public key of sender of invalid block xor deployer's public key.
                                toBeSlashed!(invalidBlocks.getOrElse(blockHash, userPk)) |
                                for (@validator <- toBeSlashed) {
                                  new commitRewardsCh, accDepositsDoneCh in {
                                    // Slashed funds:
                                    // + valPendingRewards
                                    // + state.get("committedRewards").get(validator)
                                    // + state.get("allBonds").get(validator)
                                    // Collects all deposits from per validator vaults.
                                    accumulateDeposits!(*accDepositsDoneCh) |
                                    for (_ <- accDepositsDoneCh) {
                                      new pendingRewardsAllCh in {
                                        // Collects pending rewards from each validator and resets to zero.
                                        PendingRewards!("collect", state.get("activeValidators"), *pendingRewardsAllCh) |
                                        for (@pendingRewards <- pendingRewardsAllCh) {
                                          new ackInitCh in {
                                            // Initialize empty pending rewards state with current set of validators.
                                            PendingRewards!("init", state.get("activeValidators"), *ackInitCh) |
                                            for (_ <- ackInitCh) {
                                              // Add all pending rewards to global committed rewards.
                                              commitRewards!(pendingRewards, state.get("committedRewards"), *commitRewardsCh)
                                            }
                                          }
                                        }
                                      } |
                                      for (@committedRewardsList <- commitRewardsCh) {
                                        // Collects slashed validator's committed rewards and bond.
                                        valRewardsCh!(committedRewardsList.toMap().get(validator)) |
                                        valBondCh!(state.get("allBonds").get(validator)) |
                                        for (@valRewards <- valRewardsCh;
                                             @valBond    <- valBondCh) {
                                          // Transfers slashed funds to Coop vault and updates state.
                                          new transferDoneCh in {
                                            @posVault!(
                                              "transfer",
                                              coopRevAddress,
                                              valRewards + valBond,
                                              posAuthKey,
                                              *transferDoneCh
                                            ) |
                                            for (_ <- transferDoneCh) {
                                              // Sets slashed validator's committed rewards and bond to 0 in state.
                                              slashResultCh!({
                                                "allBonds"        : state.get("allBonds").set(validator, 0),
                                                "activeValidators": state.get("activeValidators"),
                                                "committedRewards": committedRewardsList.toMap().set(validator, 0),
                                                "withdrawers"     : state.get("withdrawers"),
                                                "randomImages"    : state.get("randomImages"),
                                                "randomNumbers"   : state.get("randomNumbers")
                                              },
                                              Nil)
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      returnCh!((false, "Invalid system auth token"))
                    }
                  }
                }
              } |
              // Private method which signals the end of block processing.
              contract PoS(@"closeBlock", @sysAuthToken, ackCh) = {
                new isValidTokenCh in {
                  sysAuthTokenOps!("check", sysAuthToken, *isValidTokenCh) |
                  for (@isValid <- isValidTokenCh) {
                    if (isValid) {
                      new changeEpoch, payWithdrawers,
                          removeQuarantinedWithdrawers
                      in {
                        new blockDataCh, stateProcessCh,
                            getBlockData(`rho:block:data`),
                            accDepositsDoneCh, commitRewardsCh,
                            newValidatorsCh, removeQuarantinedCh,
                            paymentDoneCh
                        in {
                          getBlockData!(*blockDataCh) |
                          runMVar!(*stateCh, *stateProcessCh, *ackCh) |
                          for (@blockNumber, _, _    <- blockDataCh;
                               @state, stateUpdateCh <- stateProcessCh) {
                            // Before choosing new active validators and paying out any withdrawers (i.e. updating the state),
                            // per validator vaults are accumulated into the PoS vault.
                            accumulateDeposits!(*accDepositsDoneCh) |
                            // Checks if epoch changes:
                            // If so, choose new active validators.
                            // If not, active validators remain the same.
                            changeEpoch!(
                              blockNumber,
                              state.get("allBonds"),
                              state.get("activeValidators"),
                              state.get("withdrawers"),
                              *newValidatorsCh
                            ) |
                            new pendingRewardsAllCh in {
                              // Collects pending rewards from all validators and resets to zero.
                              PendingRewards!("collect", state.get("activeValidators"), *pendingRewardsAllCh) |
                              for (@pendingRewards <- pendingRewardsAllCh) {
                                for (@newValidatorKeys <<- newValidatorsCh) {
                                  new ackInitCh in {
                                    // Initialize empty pending rewards state with new set of validators.
                                    PendingRewards!("init", newValidatorKeys, *ackInitCh) |
                                    for (_ <- ackInitCh) {
                                      // Add all pending rewards to global committed rewards.
                                      commitRewards!(pendingRewards, state.get("committedRewards"), *commitRewardsCh)
                                    }
                                  }
                                }
                              }
                            } |
                            // After pending rewards are committed, quarantined withdrawers are removed
                            // from the bonds and withdrawers maps.
                            for (@committedRewards <- commitRewardsCh) {
                              removeQuarantinedWithdrawers!(
                                blockNumber,
                                state.get("allBonds"),
                                state.get("withdrawers"),
                                committedRewards,
                                *removeQuarantinedCh)
                            } |
                            // After new active validators are selected, deposits are accumulated, and
                            // quarantined withdrawers are removed from the bonds map,
                            // these withdrawing validators are paid out, then the state is updated.
                            for (@newValidators                                    <- newValidatorsCh;
                                 @(payments, newBonds, newWithdrawers, newRewards) <- removeQuarantinedCh;
                                 _                                                 <- accDepositsDoneCh) {
                              payWithdrawers!(payments, *paymentDoneCh) |
                              for (_ <- paymentDoneCh) {
                                stateUpdateCh!({
                                  "allBonds"        : newBonds,
                                  "activeValidators": newValidators,
                                  "committedRewards": newRewards,
                                  "withdrawers"     : newWithdrawers,
                                  "randomImages"    : {},
                                  "randomNumbers"   : {},
                                },
                                Nil)
                              }
                            }
                          }
                        } |
                        // Moves the entire contents of a validator's vault to the PoS vault.
                        new moveFunds in {
                          contract moveFunds(@(unf, _, vault), returnCh) = {
                            new balanceCh, unfAuthKeyCh, transferDoneCh in {
                              @vault!("balance", *balanceCh) |
                              for (@balance <- balanceCh) {
                                if (balance > 0) {
                                  @RevVault!("unforgeableAuthKey", unf, *unfAuthKeyCh) |
                                  for (@authKey <- unfAuthKeyCh) {
                                    // Transfer funds from validator vault to the PoS vault.
                                    @vault!("transfer", posRevAddress, balance, authKey, *transferDoneCh) |
                                    for (@(true, Nil) <- transferDoneCh) {
                                      returnCh!(true)
                                    }
                                  }
                                } else {
                                  returnCh!(true)
                                }
                              }
                            }
                          } |
                          // Transfers all accumulated funds to the PoS vault.
                          contract accumulateDeposits(ackCh) = {
                            for (@vaults <<- perActiveValidatorPosVaultsCh) {
                              @ListOps!("parMap", vaults, *moveFunds, *ackCh)
                            }
                          }
                        } |
                        // Transfers withdrawing validator's bond + accumulated (committed) rewards from PoS vault to their vault.
                        new payWithdrawer in {
                          contract payWithdrawer(@(pk, amount), returnCh) = {
                            new vaultCh, revAddressCh in {
                              revAddressOps!("fromPublicKey", pk, *revAddressCh) |
                              for (@toRevAddress <- revAddressCh) {
                                @posVault!("transfer", toRevAddress, amount, posAuthKey, *returnCh)
                              }
                            }
                          } |
                          contract payWithdrawers(@payments, ackCh) = {
                            @ListOps!("unorderedParMap", payments, *payWithdrawer, *ackCh)
                          }
                        } |
                        // Adds pending rewards to global committed rewards for bookkeeping.
                        new commitReward in {
                          contract commitReward(@(pk, pending), @acc, resultCh) = {
                            resultCh!(acc.set(pk, acc.getOrElse(pk, 0) + pending))
                          } |
                          contract commitRewards(@pendingRewards, @rewards, newRewardsCh) = {
                            @ListOps!("fold", pendingRewards.toList(), rewards, *commitReward, *newRewardsCh)
                          }
                        } |
                        // Checks if epoch changes, then does appropriate action.
                        contract changeEpoch(@currentBlockNumber, @allBonds, @activeValidators, @withdrawers, resultCh) = {
                          if (currentBlockNumber % $$epochLength$$ == 0) {
                            pickActiveValidators!(allBonds, withdrawers, *resultCh)
                          } else {
                            resultCh!(activeValidators)
                          }
                        } |
                        // Checks withdrawer's quarantine period against current block number,
                        // then computes their payment, removes them from the bonds and withdrawers maps, and
                        // updates the committed rewards map.
                        contract removeQuarantinedWithdrawers(@currentBlockNumber, @allBonds, @withdrawers, @rewards, returnCh) = {
                          new quarantinedValidatorsCh, validatorsToWithdrawListCh,
                              isQuarantineFinished, notWithdrawn,
                              paymentsCh, computePay,
                              newBondsListCh, newWithdrawersListCh,
                              newRewardsListCh
                          in {
                            @ListOps!("filter", withdrawers.toList(), *isQuarantineFinished, *quarantinedValidatorsCh) |
                            for (@quarantinedValidators <- quarantinedValidatorsCh) {
                              @ListOps!("map", quarantinedValidators, *fst, *validatorsToWithdrawListCh) |
                              for (@validatorsToWithdrawList <- validatorsToWithdrawListCh) {
                                @ListOps!("map", validatorsToWithdrawList, *computePay, *paymentsCh) |
                                contract computePay(@pk, resultCh) = {
                                  resultCh!((pk, allBonds.get(pk) + rewards.getOrElse(pk, 0)))
                                } |
                                match validatorsToWithdrawList.toSet() {
                                  validatorsToWithdrawSet => {
                                    @ListOps!("filter", allBonds.toList(), *notWithdrawn, *newBondsListCh) |
                                    @ListOps!("filter", withdrawers.toList(), *notWithdrawn, *newWithdrawersListCh) |
                                    @ListOps!("filter", rewards.toList(), *notWithdrawn, *newRewardsListCh) |
                                    for (@newWithdrawersList <- newWithdrawersListCh;
                                         @newBondsList       <- newBondsListCh;
                                         @newRewardsList     <- newRewardsListCh;
                                         @payments           <- paymentsCh) {
                                      returnCh!((payments, newBondsList.toMap(), newWithdrawersList.toMap(), newRewardsList.toMap()))
                                    } |
                                    // Checks that the validator is not a withdrawer.
                                    contract notWithdrawn(@(pk, _), resultCh) = {
                                      resultCh!(not validatorsToWithdrawSet.contains(pk))
                                    }
                                  }
                                }
                              }
                            } |
                            // Check whether quarantine period is finished.
                            contract isQuarantineFinished(@(_, blockNumber), resultCh) = {
                              resultCh!(blockNumber >= currentBlockNumber)
                            }
                          }
                        }
                      }
                    } else {
                      ackCh!((false, "Invalid system auth token"))
                    }
                  }
                }
              }
            } |
            //
            contract PoS(@"commitRandomImage", @deployerId, @hash, ackCh) = {
              new userCh, mvarCh in {
                getUser!(deployerId, *userCh) |
                runMVar!(*stateCh, *mvarCh, *ackCh) |
                for (@validator       <- userCh;
                     @state, resultCh <- mvarCh) {
                  if (state.get("randomImages").contains(validator)) {
                    resultCh!(state, (false, "Image already committed"))
                  } else {
                    resultCh!(
                      state.set("randomImages", state.get("randomImages").set(validator, hash)), true)
                  }
                }
              }
            } |
            //
            contract PoS(@"revealRandom", @deployerId, @random, ackCh) = {
              new userCh, mvarCh, computeHash(`rho:crypto:keccak256Hash`), hashCh in {
                getUser!(deployerId, *userCh) |
                runMVar!(*stateCh, *mvarCh, *ackCh) |
                computeHash!(random, *hashCh) |
                for (@validator       <- userCh;
                     @state, resultCh <- mvarCh;
                     @hash            <- hashCh) {
                  if (state.get("randomImages").contains(validator)) {
                    if (hash == state.get("randomImages").get(validator)) {
                      resultCh!(
                        state.set("randomNumbers",state.get("randomNumbers").set(validator, random)),
                        true)
                    } else {
                      resultCh!(state, (false, "Previously committed image doesn't match the random number"))
                    }
                  } else {
                    resultCh!(state, (false, "Previously committed random image not found"))
                  }
                }
              }
            } |
            // Initialize pending rewards state for each validator
            contract PendingRewards(@"init", @validatorKeys, @return) = {
              new createStateKeyCh in {
                @ListOps!("map", validatorKeys, *createStateKeyCh, return) |
                contract createStateKeyCh(@key, @ackCh) = {
                  TreeHashMap!("set", pendingRewardsMap, key, {}, ackCh)
                }
              }
            } |
            // Sum of new pending rewards with existing state
            contract PendingRewards(@"append", @validatorKey, @newRewards, @return) = {
              new currentRewardsCh in {
                // Get existing pending rewards (per validator)
                // - validator key is always initialized so here we can use unsafe get
                TreeHashMap!("fastUnsafeGet", pendingRewardsMap, validatorKey, *currentRewardsCh) |
                for (@currentRewards <- currentRewardsCh) {
                  new mergeResultCh in {
                    // Merge (sum) current pending rewards with new pending rewards
                    MergeIntMaps!(currentRewards, newRewards, *mergeResultCh) |
                    for (@mergeResult <- mergeResultCh) {
                      // Update pending rewards state
                      TreeHashMap!("set", pendingRewardsMap, validatorKey, mergeResult, return)
                    }
                  }
                }
              }
            } |
            // Collect pending rewards from all validators (in a map) / reset state to zero.
            contract PendingRewards(@"collect", @validatorKeys, @return) = {
              new collectMaps, mapsListCh in {
                // Get pending rewards (maps) for list of validators (public keys).
                @ListOps!("fold", validatorKeys, [], *collectMaps, *mapsListCh) |
                contract collectMaps(@validatorKey, @acc, mergeRet) = {
                  new updateCh, updateAckCh in {
                    // Update (per validator) pending rewards.
                    // - collect existing values and reset to empty map
                    TreeHashMap!("update", pendingRewardsMap, validatorKey, *updateCh, *updateAckCh) |
                    for (@rewardsMap, rewardsRet <- updateCh) {
                      // Reset per validator pending rewards state.
                      rewardsRet!({}) |
                      // Accumulate all rewards maps.
                      for (_ <- updateAckCh) {
                        mergeRet!(acc ++ [rewardsMap])
                      }
                    }
                  }
                } |
                // Merge all pending rewards maps into one map.
                for (@mapsList <- mapsListCh) {
                  @ListOps!("fold", mapsList, {}, *MergeIntMaps, return)
                }
              }
            }
          }
        } |
        // Transfers funds from deployer to block sender.
        contract deposit(@deployerId, @amount, @activeValidators, returnCh) = {
          new vaultCh, revAddressCh,
              indexSender, authKeyCh,
              getBlockData(`rho:block:data`), blockDataCh
          in {
            @RevVault!("deployerAuthKey", deployerId, *authKeyCh) |
            revAddressOps!("fromDeployerId", deployerId, *revAddressCh) |
            for (@authKey        <- authKeyCh;
                 @fromRevAddress <- revAddressCh) {
              @RevVault!("findOrCreate", fromRevAddress, *vaultCh) |
              getBlockData!(*blockDataCh) |
              for (@(true, fromVault) <- vaultCh;
                   _, _, @sender      <- blockDataCh) {
                @ListOps!("indexOf", activeValidators, sender, *indexSender) |
                for (@idx <- indexSender) {
                  for (@vaults <<- perActiveValidatorPosVaultsCh) {
                    if (idx == -1) {
                      returnCh!((false, "Sender is not an active validator"))
                    } else {
                      match vaults.nth(idx) {
                        (_, activeValidatorVault, _) => {
                          @fromVault!("transfer", activeValidatorVault, amount, authKey, *returnCh)
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } |
        // Stake-weighted distribution of final deployment cost for bookkeeping in validator state.
        contract distributeRewards(@amount, @activeValidators, @bonds, returnCh) = {
          new computeSum, computeDelta, totalActiveStakeCh in {
            @ListOps!("fold", activeValidators, 0, *computeSum, *totalActiveStakeCh) |
            contract computeSum(@pk, @acc, resultCh) = {
              resultCh!(acc + bonds.get(pk))
            } |
            // Computes the rewards delta for each active validator.
            for (@totalActiveStake <- totalActiveStakeCh) {
              @ListOps!("fold", activeValidators, {}, *computeDelta, *returnCh) |
              // Stake-weighted rewards delta map.
              contract computeDelta(@pk, @acc, resultCh) = {
                resultCh!(acc.set(pk, (amount * bonds.get(pk)) / totalActiveStake))
              }
            }
          }
        }
      } |
      // Updates value stored on varCh by sending the new value to resultCh.
      contract runMVar(varCh, processCh, returnCh) = {
        new resultCh in {
          for (@v <- varCh) {
            processCh!(v, *resultCh) |
            for (@newV, @result <- resultCh) {
              varCh!(newV) |
              returnCh!(result)
            }
          }
        }
      } |
      // Discards second element of a pair.
      contract fst(@(first, _), resultCh) = {
        resultCh!(first)
      } |
      // Retrieves deployer's public key.
      contract getUser(@deployerId, returnCh) = {
        new deployerIdOps(`rho:rchain:deployerId:ops`) in {
          deployerIdOps!("pubKeyBytes", deployerId, *returnCh)
        }
      } |
      // Selects set of active validators from the set of available validators.
      contract pickActiveValidators(@allBonds, @withdrawers, returnCh) = {
        new availableValidatorsCh,
            isAvailable, pksCh
        in {
          @ListOps!("filter", allBonds.toList(), *isAvailable, *availableValidatorsCh) |
          contract isAvailable(@(pk, _), resultCh) = {
            resultCh!(not withdrawers.contains(pk))
          } |
          for (@availableValidators <- availableValidatorsCh) {
            @ListOps!("map", availableValidators, *fst, *pksCh) |
            for (@pks <- pksCh) {
              // TODO: Randomly select 100 active validators once we have on-chain randomness
              returnCh!(pks.take($$numberOfActiveValidators$$))
            }
          }
        }
      }
    } |
    // Merge (sum) maps with integer values
    // MergeIntMaps({"a": 1, "b": 4}, {"a": 2, "c": 5, "d": Nil})
    //            = {"a": 3, "b": 4, "c": 5}
    contract MergeIntMaps(@map1, @map2, return) = {
      new mergeKey in {
        @ListOps!("fold", map2.toList(), map1, *mergeKey, *return) |
        contract mergeKey(@(key, v1), @acc, ret) = {
          match (v1, acc.get(key)) {
            (Int, v2 /\ Int) => ret!(acc.set(key, v1 + v2))
            (Int, _)         => ret!(acc.set(key, v1))
            (_, v2 /\ Int)   => ret!(acc.set(key, v2))
            _                => ret!(acc)
          }
        }
      }
    } |
    // Registers signed write-only POS contract bundle.
    rs!(
      "047b43d6548b72813b89ac1b9f9ca67624a8b372feedd71d4e2da036384a3e1236812227e524e6f237cde5f80dbb921cac12e6500791e9a9ed1254a745a816fe1f".hexToBytes(),
      (9223372036854775807, bundle+{*PoS}),
      "3044022054ff4bae3984252b116e41e28d98bb5533eaa39aec2729228159166e2784f641022066a0fd99e7ea33df812fab095cbe61250f9548bce6da3ec4c6a90c741b94087f".hexToBytes(),
      *uriOut)
  }
}
